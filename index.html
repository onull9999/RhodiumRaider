<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rhodium Token Raider</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f4f4f4;
            color: #333;
            line-height: 1.6;
        }
        h1 {
            color: #444;
            border-bottom: 1px solid #ddd;
            padding-bottom: 10px;
        }
        label {
            display: block;
            margin-top: 15px;
            font-weight: bold;
        }
        input[type="text"], 
        input[type="number"], 
        textarea, 
        select {
            width: 100%;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            box-sizing: border-box;
            margin-top: 5px;
        }
        input[type="range"] {
            width: 200px;
            vertical-align: middle;
        }
        #logs {
            margin-top: 20px;
            height: 300px;
            border: 1px solid #ccc;
            background: #222;
            color: #eee;
            padding: 15px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
            border-radius: 5px;
        }
        .token-input {
            margin-bottom: 10px;
        }
        button {
            margin-top: 15px;
            padding: 12px 20px;
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #218838;
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        .error {
            color: #ff6b6b;
        }
        .success {
            color: #51cf66;
        }
        .warning {
            color: #fcc419;
        }
        .info {
            color: #339af0;
        }
        .section {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="section">
        <h1>Rhodium Token Raider</h1>
        <p>Edit By <a href="https://github.com/onull9999/" target="_blank">@onull9999</a></p>
        <p><a href="https://discord.gg/„Åì„Åì„Çä„Çì„Åè" target="_blank">Join the Discord</a></p>

        <h3><u>Update History</u></h3>
        <p>
            <u>2025/5/12</u><br>Spammer„ÇíÂÆüË£Ö<br>
            <u>2025/5/13</u><br>GroupSpamÂÆüË£Ö<br>LogÂÆüË£Ö<br>
            <u>2025/5/14</u><br>ReactionSpammerÂÆüË£Ö<br>
            <u>2025/5/15</u><br>JoinnerÂÆüË£Ö
        </p>
    </div>

    <div class="section">
        <label>Mode:
            <select id="mode">
                <option value="spammer">Spammer</option>
                <option value="groupspam">Group Spam</option>
                <option value="reactionspam">Reaction Spam</option>
                <option value="joinner">Joinner</option>
            </select>
        </label>
        
        <label>Use Tokens: <span id="tokenCountLabel">1</span>
            <input type="range" id="tokenCount" min="1" max="10" value="1" />
        </label>
        <div id="tokenInputs"></div>
    </div>

    <div id="spammerInputs" class="section">
        <label>Server ID: <input type="text" id="serverId" placeholder="Enter Server ID"></label>
        <label>Channel ID: <input type="text" id="channelId" placeholder="Enter Channel ID"></label>
        <label>Message: <textarea id="message" rows="4" placeholder="Enter message to send"></textarea></label>
        <label>Send Interval (ms): <input type="number" id="interval" value="1000" min="100"></label>
    </div>

    <div id="groupSpamInputs" class="section hidden">
        <label>User ID(s) (comma-separated): <input type="text" id="userId" placeholder="Enter User IDs separated by commas"></label>
        <label>Groups to Create: <input type="number" id="groupCount" value="1" min="1"></label>
        <label>Group Name: <input type="text" id="groupName" placeholder="Enter Group Name"></label>
        <label>Create Interval (ms): <input type="number" id="createInterval" value="1000" min="100"></label>
    </div>

    <div id="reactionSpamInputs" class="section hidden">
        <label>Channel ID: <input type="text" id="channelIdReaction" placeholder="Enter Channel ID"></label>
        <label>Message ID: <input type="text" id="messageId" placeholder="Enter Message ID"></label>
        <div id="emojiStatus">ÁµµÊñáÂ≠ó„Éï„Ç°„Ç§„É´: <span id="emojiCount">0</span> ÂÄãË™≠„ÅøËæº„ÅøÊ∏à„Åø</div>
    </div>

    <div id="joinnerInputs" class="section hidden">
        <label>Server Link: <input type="text" id="serverLink" placeholder="Discord server invite link"></label>
    </div>

    <div class="section">
        <label><input type="checkbox" id="useProxy"> Use Proxy</label>
        <label id="proxyLabel" class="hidden">
            Proxy URL: <input type="text" id="proxyUrl" placeholder="e.g. https://cors-anywhere.herokuapp.com/">
        </label>
    </div>

    <div class="section">
        <button id="startBtn">Run</button>
        <button id="stopBtn" disabled>Stop</button>
        <button id="clearLogBtn">Clear Log</button>
        <button id="testEmojiBtn">Test Emoji Load</button>
    </div>

    <div class="section">
        <h3>Execution Log</h3>
        <div id="logs"></div>
    </div>

    <script>
        // DOM Elements
        const elements = {
            modeSelect: document.getElementById('mode'),
            spammerInputs: document.getElementById('spammerInputs'),
            groupSpamInputs: document.getElementById('groupSpamInputs'),
            reactionSpamInputs: document.getElementById('reactionSpamInputs'),
            joinnerInputs: document.getElementById('joinnerInputs'),
            tokenCountInput: document.getElementById('tokenCount'),
            tokenCountLabel: document.getElementById('tokenCountLabel'),
            tokenInputsDiv: document.getElementById('tokenInputs'),
            useProxyCb: document.getElementById('useProxy'),
            proxyLabel: document.getElementById('proxyLabel'),
            proxyInput: document.getElementById('proxyUrl'),
            logsDiv: document.getElementById('logs'),
            startBtn: document.getElementById('startBtn'),
            stopBtn: document.getElementById('stopBtn'),
            clearLogBtn: document.getElementById('clearLogBtn'),
            testEmojiBtn: document.getElementById('testEmojiBtn'),
            emojiCountSpan: document.getElementById('emojiCount')
        };

        // State
        let state = {
            intervalId: null,
            isRunning: false,
            emojis: []
        };

        // Initialize
        function init() {
            updateTokenInputs(parseInt(elements.tokenCountInput.value, 10));
            setupEventListeners();
            loadEmojis();
        }

        // Event Listeners
        function setupEventListeners() {
            elements.modeSelect.addEventListener('change', handleModeChange);
            elements.tokenCountInput.addEventListener('input', handleTokenCountChange);
            elements.useProxyCb.addEventListener('change', handleProxyChange);
            elements.clearLogBtn.addEventListener('click', clearLogs);
            elements.startBtn.addEventListener('click', startOperation);
            elements.stopBtn.addEventListener('click', stopOperation);
            elements.testEmojiBtn.addEventListener('click', testEmojiLoad);
        }

        // Handlers
        function handleModeChange() {
            const mode = elements.modeSelect.value;
            elements.spammerInputs.classList.toggle('hidden', mode !== 'spammer');
            elements.groupSpamInputs.classList.toggle('hidden', mode !== 'groupspam');
            elements.reactionSpamInputs.classList.toggle('hidden', mode !== 'reactionspam');
            elements.joinnerInputs.classList.toggle('hidden', mode !== 'joinner');
        }

        function handleTokenCountChange() {
            const count = parseInt(elements.tokenCountInput.value, 10);
            elements.tokenCountLabel.textContent = count;
            updateTokenInputs(count);
        }

        function handleProxyChange() {
            elements.proxyLabel.classList.toggle('hidden', !elements.useProxyCb.checked);
        }

        // Core Functions
        function updateTokenInputs(count) {
            elements.tokenInputsDiv.innerHTML = '';
            for (let i = 0; i < count; i++) {
                const input = document.createElement('input');
                input.type = 'text';
                input.placeholder = `Token ${i + 1}`;
                input.className = 'token-input';
                elements.tokenInputsDiv.appendChild(input);
            }
        }

        async function loadEmojis() {
            try {
                const response = await fetch('emoji.txt');
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                
                const text = await response.text();
                state.emojis = text.split('\n')
                    .map(emoji => emoji.trim())
                    .filter(emoji => emoji && isValidEmoji(emoji));
                
                elements.emojiCountSpan.textContent = state.emojis.length;
                log(`Successfully loaded ${state.emojis.length} emojis`, 'success');
            } catch (error) {
                log(`Failed to load emoji file: ${error.message}`, 'error');
                state.emojis = ['üòÄ', 'üëç', 'üéâ']; // Default emojis
                elements.emojiCountSpan.textContent = state.emojis.length;
            }
        }

        function isValidEmoji(emoji) {
            if (/\p{Emoji}/u.test(emoji)) return true;
            if (/^:[a-zA-Z0-9_]+:$/.test(emoji)) return true;
            return false;
        }

        async function reactToMessage(token, channelId, messageId, emoji) {
            try {
                let encodedEmoji;
                if (emoji.startsWith(':') && emoji.endsWith(':')) {
                    encodedEmoji = encodeURIComponent(emoji.slice(1, -1));
                } else {
                    encodedEmoji = encodeURIComponent(emoji);
                }

                const url = buildUrl(`https://discord.com/api/v10/channels/${channelId}/messages/${messageId}/reactions/${encodedEmoji}/@me`);
                
                const response = await fetch(url, {
                    method: 'PUT',
                    headers: {
                        'Authorization': token,
                        'Content-Type': 'application/json'
                    }
                });

                if (response.ok) {
                    log(`Token ${token.slice(0, 10)}‚Ä¶ Added reaction ${emoji}`, 'success');
                    return true;
                } else {
                    const errorText = await response.text();
                    log(`Token ${token.slice(0, 10)}‚Ä¶ Failed to add ${emoji}: ${response.status} ${errorText}`, 'error');
                    return false;
                }
            } catch (error) {
                log(`Token ${token.slice(0, 10)}‚Ä¶ Error adding ${emoji}: ${error.message}`, 'error');
                return false;
            }
        }

        async function processReactionSpam() {
            const tokens = getTokens();
            const channelId = document.getElementById('channelIdReaction').value.trim();
            const messageId = document.getElementById('messageId').value.trim();

            if (!channelId || !messageId) {
                alert('Please enter both Channel ID and Message ID');
                return false;
            }

            if (state.emojis.length === 0) {
                alert('No valid emojis loaded');
                return false;
            }

            log(`Adding ${state.emojis.length} emojis using ${tokens.length} tokens simultaneously...`, 'info');

            let successCount = 0;
            let failCount = 0;

            // „Åô„Åπ„Å¶„ÅÆÁµµÊñáÂ≠ó„Å®„Éà„Éº„ÇØ„É≥„ÅÆÁµÑ„ÅøÂêà„Çè„Åõ„Å´ÂØæ„Åó„Å¶‰∏¶ÂàóÂá¶ÁêÜ
            const promises = [];
            
            for (const emoji of state.emojis) {
                for (const token of tokens) {
                    promises.push(
                        reactToMessage(token, channelId, messageId, emoji)
                            .then(result => {
                                if (result) successCount++;
                                else failCount++;
                            })
                    );
                }
            }

            // „Åô„Åπ„Å¶„ÅÆ„É™„ÇØ„Ç®„Çπ„Éà„Çí‰∏¶ÂàóÂÆüË°å
            await Promise.all(promises);

            log(`Completed: ${successCount} succeeded, ${failCount} failed`, failCount === 0 ? 'success' : 'warning');
            return failCount === 0;
        }

        // Utility Functions
        function buildUrl(endpoint) {
            let url = endpoint;
            if (elements.useProxyCb.checked && elements.proxyInput.value.trim()) {
                let proxy = elements.proxyInput.value.trim();
                if (!proxy.endsWith('/')) proxy += '/';
                url = proxy + endpoint.replace(/^https?:\/\//, '');
            }
            return url;
        }

        function getTokens() {
            return Array.from(document.querySelectorAll('.token-input'))
                .map(input => input.value.trim())
                .filter(token => token);
        }

        function log(message, type = 'info') {
            const now = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.textContent = `[${now}] ${message}`;
            logEntry.className = type;
            elements.logsDiv.appendChild(logEntry);
            elements.logsDiv.scrollTop = elements.logsDiv.scrollHeight;
        }

        function clearLogs() {
            elements.logsDiv.innerHTML = '';
            log('Log cleared', 'success');
        }

        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Operation Control
        async function startOperation() {
            if (state.isRunning) return;

            const mode = elements.modeSelect.value;
            state.isRunning = true;
            elements.startBtn.disabled = true;
            elements.stopBtn.disabled = false;

            log(`Starting ${mode} operation...`, 'info');

            try {
                if (mode === 'reactionspam') {
                    await processReactionSpam();
                }
                // ‰ªñ„ÅÆ„É¢„Éº„Éâ„ÅÆÂá¶ÁêÜ...
            } catch (error) {
                log(`Operation error: ${error.message}`, 'error');
            } finally {
                stopOperation();
            }
        }

        function stopOperation() {
            state.isRunning = false;
            if (state.intervalId) {
                clearInterval(state.intervalId);
                state.intervalId = null;
            }
            elements.startBtn.disabled = false;
            elements.stopBtn.disabled = true;
            log('Operation stopped', 'warning');
        }

        async function testEmojiLoad() {
            log('Reloading emoji file...', 'info');
            await loadEmojis();
        }

        // Initialize the application
        init();
    </script>
